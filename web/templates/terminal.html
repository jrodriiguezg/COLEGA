{% extends "base.html" %}

{% block content %}
<style>
    .terminal-container {
        height: calc(100vh - 180px);
        display: flex;
        flex-direction: column;
        background: #000;
        border-radius: 0 0 5px 5px;
        position: relative;
    }

    .terminal-output {
        flex: 1;
        padding: 15px;
        overflow-y: auto;
        font-family: 'JetBrains Mono', monospace;
        font-size: 0.9rem;
        line-height: 1.4;
        color: #d4d4d4;
        white-space: pre-wrap;
    }

    .terminal-input-area {
        padding: 10px;
        background: #212529;
        display: flex;
        align-items: center;
        border-top: 1px solid #333;
        position: relative;
    }

    .terminal-prompt {
        color: #0f0;
        font-family: monospace;
        margin-right: 10px;
        font-weight: bold;
    }

    .terminal-input {
        flex: 1;
        background: transparent;
        border: none;
        color: white;
        font-family: monospace;
        font-size: 1rem;
        outline: none;
    }

    /* Tabs Styling */
    .nav-tabs .nav-link {
        color: #aaa;
        background-color: #1a1a1a;
        border-color: #333;
        border-bottom: none;
        margin-right: 2px;
        border-radius: 5px 5px 0 0;
    }

    .nav-tabs .nav-link.active {
        color: #fff;
        background-color: #000;
        /* Match terminal bg */
        border-color: #444 #444 #000;
    }

    .nav-tabs .nav-link:hover {
        border-color: #555 #555 #1a1a1a;
        color: #fff;
    }

    .nav-tabs {
        border-bottom: 1px solid #444;
    }

    /* Autocomplete Dropdown */
    #autocomplete-popup {
        position: absolute;
        bottom: 100%;
        left: 0;
        background: #2d2d2d;
        border: 1px solid #444;
        box-shadow: 0 -4px 10px rgba(0, 0, 0, 0.5);
        display: none;
        z-index: 1000;
        max-height: 200px;
        overflow-y: auto;
        min-width: 200px;
    }

    .ac-item {
        padding: 5px 10px;
        cursor: pointer;
        font-family: monospace;
        color: #eee;
    }

    .ac-item:hover,
    .ac-item.selected {
        background-color: #0d6efd;
        color: white;
    }
</style>

<!-- Tabs Header -->
<ul class="nav nav-tabs" id="term-tabs" role="tablist">
    <li class="nav-item" role="presentation">
        <button class="nav-link active" id="tab-1" data-bs-toggle="tab" data-bs-target="#term-1" type="button"
            role="tab">Terminal 1</button>
    </li>
    <li class="nav-item" role="presentation">
        <button class="nav-link" id="btn-add-tab" type="button" onclick="addTab()">+</button>
    </li>
</ul>

<!-- Tabs Content -->
<div class="tab-content" id="term-content">
    <!-- Terminal 1 (Default) -->
    <div class="tab-pane fade show active" id="term-1" role="tabpanel">
        <div class="terminal-container">
            <div class="terminal-output" id="output-1">Welcome to COLEGA Terminal Session 1.</div>
            <div class="terminal-input-area">
                <div id="autocomplete-popup-1" class="autocomplete-menu"></div>
                <!-- Dynamic placement logic needed or simplify -->
                <span class="terminal-prompt" id="prompt-1">admin@neo:~$</span>
                <input type="text" class="terminal-input" id="input-1" autocomplete="off"
                    onkeydown="handleTermInput(event, '1')">
            </div>
        </div>
    </div>
</div>

<!-- Autocomplete Shared Element (Moved programmatically) -->
<div id="autocomplete-popup"></div>

{% endblock %}

{% block scripts %}
<script>
    // --- Global State ---
    let tabCount = 1;
    let commandHistory = JSON.parse(localStorage.getItem('term_history') || "[]");
    const MAX_HISTORY = 100;

    // Per-tab state (Session ID -> { historyIndex, currentCwd })
    let termStates = {
        '1': { historyIndex: -1, cwd: '~' }
    };

    let acSelectionIndex = -1;
    let acMatches = [];
    let currentTermId = '1';

    // --- On Load ---
    document.addEventListener('DOMContentLoaded', () => {
        document.getElementById('input-1').focus();
    });

    // --- Tab Management ---
    const tabsList = document.getElementById('term-tabs');
    const tabsContent = document.getElementById('term-content');
    const btnAdd = document.getElementById('btn-add-tab');

    // Update currentTermId when tab changes
    tabsList.addEventListener('shown.bs.tab', function (event) {
        const targetId = event.target.getAttribute('data-bs-target'); // #term-X
        currentTermId = targetId.split('-')[1];
        setTimeout(() => document.getElementById(`input-${currentTermId}`).focus(), 50);
    });

    function addTab() {
        tabCount++;
        const id = String(tabCount);

        // 1. Add Nav Button
        const li = document.createElement('li');
        li.className = 'nav-item';
        li.role = 'presentation';
        li.innerHTML = `<button class="nav-link" id="tab-${id}" data-bs-toggle="tab" data-bs-target="#term-${id}" type="button" role="tab">Terminal ${id}</button>`;
        tabsList.insertBefore(li, tabsList.lastElementChild);

        // 2. Add Content Pane
        const div = document.createElement('div');
        div.className = 'tab-pane fade';
        div.id = `term-${id}`;
        div.role = 'tabpanel';
        div.innerHTML = `
        <div class="terminal-container">
            <div class="terminal-output" id="output-${id}">Welcome to COLEGA Terminal Session ${id}.</div>
            <div class="terminal-input-area">
                <span class="terminal-prompt" id="prompt-${id}">admin@neo:~$</span>
                <input type="text" class="terminal-input" id="input-${id}" autocomplete="off"
                       onkeydown="handleTermInput(event, '${id}')">
            </div>
        </div>`;
        tabsContent.appendChild(div);

        // 3. Init State
        termStates[id] = { historyIndex: -1, cwd: '~' };

        // 4. Activate new tab using Bootstrap API
        const triggerEl = document.querySelector(`#tab-${id}`);
        const tab = new bootstrap.Tab(triggerEl);
        tab.show();
    }

    // --- Terminal Logic ---
    function handleTermInput(e, id) {
        const input = document.getElementById(`input-${id}`);
        const output = document.getElementById(`output-${id}`);
        const promptSpan = document.getElementById(`prompt-${id}`);
        const acPopup = document.getElementById('autocomplete-popup');

        // Handle Autocomplete Navigation
        if (acPopup.style.display === 'block') {
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                acSelectionIndex = (acSelectionIndex + 1) % acMatches.length;
                renderAcItems();
                return;
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                acSelectionIndex = (acSelectionIndex - 1 + acMatches.length) % acMatches.length;
                renderAcItems();
                return;
            } else if (e.key === 'Enter') {
                e.preventDefault();
                applyAutocomplete(id, acMatches[acSelectionIndex]);
                return;
            } else if (e.key === 'Escape') {
                closeAutocomplete();
                return;
            }
        }

        // Handle Standard Inputs
        if (e.key === 'Enter') {
            const cmd = input.value;
            if (!cmd) return;

            // Save History
            commandHistory.push(cmd);
            if (commandHistory.length > MAX_HISTORY) commandHistory.shift();
            localStorage.setItem('term_history', JSON.stringify(commandHistory));

            // Reset local history index
            termStates[id].historyIndex = -1;

            // Output user command
            output.innerHTML += `\n<span style="color: #0f0">${promptSpan.innerText}</span> ${cmd}\n`;
            input.value = '';
            closeAutocomplete();
            output.scrollTop = output.scrollHeight;

            // Server Call
            fetch('/api/terminal', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ command: cmd, term_session: id })
            })
                .then(res => res.json())
                .then(data => {
                    if (data.output) output.innerHTML += ansiToHtml(data.output) + "\n";
                    if (data.cwd) {
                        updatePrompt(id, data.cwd);
                        termStates[id].cwd = data.cwd;
                    }
                    output.scrollTop = output.scrollHeight;
                });

        } else if (e.key === 'Tab') {
            e.preventDefault();
            const cmd = input.value;

            fetch('/api/terminal/complete', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ command: cmd, term_session: id })
            })
                .then(res => res.json())
                .then(data => {
                    acMatches = data.matches;
                    if (acMatches.length === 1) {
                        // Direct completion works differently depending on if it's new word or partial
                        // Simplified: just replace suffix
                        applyAutocomplete(id, acMatches[0], data.partial);
                    } else if (acMatches.length > 1) {
                        showAutocomplete(input, acMatches);
                    }
                });

        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            let idx = termStates[id].historyIndex;
            if (idx === -1) idx = commandHistory.length;

            if (idx > 0) {
                idx--;
                termStates[id].historyIndex = idx;
                input.value = commandHistory[idx];
            }
        } else if (e.key === 'ArrowDown') {
            e.preventDefault();
            let idx = termStates[id].historyIndex;
            if (idx !== -1 && idx < commandHistory.length - 1) {
                idx++;
                termStates[id].historyIndex = idx;
                input.value = commandHistory[idx];
            } else {
                termStates[id].historyIndex = -1;
                input.value = '';
            }
        }
    }

    // --- Autocomplete UI ---
    function showAutocomplete(inputEl, matches) {
        const popup = document.getElementById('autocomplete-popup');
        acSelectionIndex = 0;

        // Position popup above input
        const rect = inputEl.parentElement.getBoundingClientRect();
        popup.style.bottom = (window.innerHeight - rect.top) + 'px';
        popup.style.left = (rect.left + 50) + 'px'; // Offset a bit
        popup.style.display = 'block';

        renderAcItems();
    }

    function renderAcItems() {
        const popup = document.getElementById('autocomplete-popup');
        popup.innerHTML = acMatches.map((m, i) =>
            `<div class="ac-item ${i === acSelectionIndex ? 'selected' : ''}" 
                  onclick="selectAcItem(${i})">${m}</div>`
        ).join('');
    }

    // Global scope for onclick
    window.selectAcItem = function (index) {
        applyAutocomplete(currentTermId, acMatches[index]);
    }

    function closeAutocomplete() {
        document.getElementById('autocomplete-popup').style.display = 'none';
        acMatches = [];
    }

    function applyAutocomplete(id, match, partial) {
        const input = document.getElementById(`input-${id}`);
        // Basic logic: if we have a partial token, replace it. 
        // If not (e.g. from Enter selection which doesn't pass partial), we need to guess or just append.
        // For simplicity: Append if match doesn't start with partial, or replace suffix.

        // Re-read current partial from input if not provided
        const val = input.value;
        const tokens = val.split(' ');
        const lastToken = tokens[tokens.length - 1];

        // If match starts with lastToken (e.g. "Do" -> "Documents/"), append suffix
        if (match.startsWith(lastToken)) {
            const suffix = match.substring(lastToken.length);
            input.value += suffix;
        } else {
            // It might be complex path replacement. Let's simplistically replace last token
            tokens[tokens.length - 1] = match;
            input.value = tokens.join(' ');
        }

        closeAutocomplete();
        input.focus();
    }

    // --- Helpers ---
    function updatePrompt(id, cwd) {
        const span = document.getElementById(`prompt-${id}`);
        if (cwd.startsWith('/home/')) {
            const parts = cwd.split('/');
            if (parts.length >= 3) {
                cwd = '~' + cwd.substring(parts.slice(0, 3).join('/').length);
            }
        }
        span.innerText = `admin@neo:${cwd}$`;
    }

    function ansiToHtml(text) {
        if (!text) return '';
        const colors = {
            '30': 'black', '31': '#ff5555', '32': '#50fa7b', '33': '#f1fa8c',
            '34': '#bd93f9', '35': '#ff79c6', '36': '#8be9fd', '37': 'white',
            '0': 'inherit', '1': 'bold'
        };
        return text.replace(/\033\[([0-9;]+)m/g, (match, codes) => {
            const style = [];
            codes.split(';').forEach(code => {
                if (colors[code]) {
                    if (code === '1') style.push('font-weight: bold');
                    else if (code !== '0') style.push(`color: ${colors[code]}`);
                }
            });
            return style.length ? `<span style="${style.join(';')}">` : '</span>';
        }) + '</span>';
    }
</script>
{% endblock %}